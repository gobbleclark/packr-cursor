"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/lib/message-parser.ts":
/*!***********************************!*\
  !*** ./src/lib/message-parser.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectActionIntent: function() { return /* binding */ detectActionIntent; },\n/* harmony export */   generateSystemResponse: function() { return /* binding */ generateSystemResponse; },\n/* harmony export */   parseMessage: function() { return /* binding */ parseMessage; }\n/* harmony export */ });\n/**\n * Message Parser Service\n * Detects entities like order numbers, SKUs, tracking numbers in chat messages\n */ /**\n * Order number patterns to detect:\n * - #12345, ##12345 (legacy with hashes - normalize to clean number)\n * - Order 12345, Order #12345\n * - order number 12345\n * - Various formats with letters/numbers\n */ const ORDER_PATTERNS = [\n    // Hash prefix: #12345, ##12345, #ORDER-12345 (normalize by removing hashes)\n    /(?:^|\\s)(#+)([A-Z]*[0-9]{3,}[A-Z0-9]*)/gi,\n    // Order keyword: \"Order 12345\", \"order #12345\", \"order number 12345\"\n    /(?:^|\\s)order\\s*(?:number\\s*)?(#+)?([A-Z0-9]{3,})/gi,\n    // Order ID patterns: \"order id: 12345\"\n    /(?:^|\\s)order\\s*id\\s*:?\\s*(#+)?([A-Z0-9]{3,})/gi,\n    // Standalone numbers that look like orders (5+ digits)\n    /(?:^|\\s)(#+)?([0-9]{5,})/g\n];\n/**\n * SKU patterns to detect:\n * - SKU: ABC123, SKU-ABC123\n * - Product codes\n */ const SKU_PATTERNS = [\n    /(?:^|\\s)SKU\\s*:?\\s*([A-Z0-9\\-_]{3,})/gi,\n    /(?:^|\\s)product\\s*(?:code|id)\\s*:?\\s*([A-Z0-9\\-_]{3,})/gi\n];\n/**\n * Tracking number patterns\n */ const TRACKING_PATTERNS = [\n    /(?:^|\\s)tracking\\s*(?:number|#)?\\s*:?\\s*([A-Z0-9]{8,})/gi,\n    /(?:^|\\s)track\\s*:?\\s*([A-Z0-9]{8,})/gi\n];\n/**\n * Parse a message and extract entities\n */ function parseMessage(content) {\n    const entities = [];\n    const orderNumbers = [];\n    // Detect order numbers\n    ORDER_PATTERNS.forEach((pattern)=>{\n        const matches = [\n            ...content.matchAll(pattern)\n        ];\n        matches.forEach((match)=>{\n            // Extract the clean order number (removing hash prefixes)\n            let orderNumber = \"\";\n            let orderNumberMatch = \"\";\n            if (match[2]) {\n                // Pattern with hash prefix: match[1] = hashes, match[2] = order number\n                orderNumber = match[2].toUpperCase();\n                orderNumberMatch = match[2];\n            } else if (match[1] && !match[2]) {\n                // Pattern without hash prefix: match[1] = order number\n                orderNumber = match[1].toUpperCase();\n                orderNumberMatch = match[1];\n            }\n            if (orderNumber && orderNumberMatch) {\n                const startIndex = match.index + match[0].indexOf(orderNumberMatch);\n                entities.push({\n                    type: \"order\",\n                    value: orderNumber,\n                    startIndex,\n                    endIndex: startIndex + orderNumberMatch.length,\n                    confidence: calculateOrderConfidence(match[0], content)\n                });\n                if (!orderNumbers.includes(orderNumber)) {\n                    orderNumbers.push(orderNumber);\n                }\n            }\n        });\n    });\n    // Detect SKUs\n    SKU_PATTERNS.forEach((pattern)=>{\n        const matches = [\n            ...content.matchAll(pattern)\n        ];\n        matches.forEach((match)=>{\n            if (match[1]) {\n                entities.push({\n                    type: \"sku\",\n                    value: match[1].toUpperCase(),\n                    startIndex: match.index + match[0].indexOf(match[1]),\n                    endIndex: match.index + match[0].indexOf(match[1]) + match[1].length,\n                    confidence: 0.9\n                });\n            }\n        });\n    });\n    // Detect tracking numbers\n    TRACKING_PATTERNS.forEach((pattern)=>{\n        const matches = [\n            ...content.matchAll(pattern)\n        ];\n        matches.forEach((match)=>{\n            if (match[1]) {\n                entities.push({\n                    type: \"tracking\",\n                    value: match[1].toUpperCase(),\n                    startIndex: match.index + match[0].indexOf(match[1]),\n                    endIndex: match.index + match[0].indexOf(match[1]) + match[1].length,\n                    confidence: 0.95\n                });\n            }\n        });\n    });\n    // Remove duplicates and sort by confidence\n    const uniqueEntities = entities.filter((entity, index, self)=>index === self.findIndex((e)=>e.type === entity.type && e.value === entity.value)).sort((a, b)=>b.confidence - a.confidence);\n    return {\n        originalContent: content,\n        entities: uniqueEntities,\n        hasOrderNumber: orderNumbers.length > 0,\n        orderNumbers: [\n            ...new Set(orderNumbers)\n        ] // Remove duplicates\n    };\n}\n/**\n * Calculate confidence score for order number detection\n */ function calculateOrderConfidence(match, fullContent) {\n    let confidence = 0.7; // Base confidence\n    // Higher confidence if explicitly mentioned as \"order\"\n    if (/order/i.test(match)) {\n        confidence += 0.2;\n    }\n    // Higher confidence if hash prefix\n    if (match.includes(\"#\")) {\n        confidence += 0.1;\n    }\n    // Context clues in the full message\n    const contextClues = [\n        \"change\",\n        \"update\",\n        \"cancel\",\n        \"modify\",\n        \"edit\",\n        \"ship\",\n        \"address\",\n        \"customer\",\n        \"delivery\",\n        \"tracking\",\n        \"status\",\n        \"problem\",\n        \"issue\"\n    ];\n    if (contextClues.some((clue)=>fullContent.toLowerCase().includes(clue))) {\n        confidence += 0.1;\n    }\n    return Math.min(confidence, 1.0);\n}\n/**\n * Check if a message suggests the user wants to take action on an order\n */ function detectActionIntent(content, entities) {\n    const lowerContent = content.toLowerCase();\n    const actionKeywords = {\n        \"update_address\": [\n            \"address\",\n            \"ship to\",\n            \"shipping\",\n            \"delivery\",\n            \"move\",\n            \"relocate\"\n        ],\n        \"cancel_order\": [\n            \"cancel\",\n            \"stop\",\n            \"halt\",\n            \"abort\",\n            \"remove\"\n        ],\n        \"modify_items\": [\n            \"add\",\n            \"remove\",\n            \"change items\",\n            \"modify\",\n            \"different\",\n            \"swap\"\n        ],\n        \"expedite\": [\n            \"rush\",\n            \"urgent\",\n            \"asap\",\n            \"expedite\",\n            \"faster\",\n            \"priority\"\n        ],\n        \"track_order\": [\n            \"track\",\n            \"status\",\n            \"where is\",\n            \"shipped\",\n            \"delivery\"\n        ],\n        \"contact_customer\": [\n            \"customer\",\n            \"client\",\n            \"contact\",\n            \"call\",\n            \"email\"\n        ]\n    };\n    const suggestedActions = [];\n    let totalConfidence = 0;\n    Object.entries(actionKeywords).forEach((param)=>{\n        let [action, keywords] = param;\n        const matches = keywords.filter((keyword)=>lowerContent.includes(keyword));\n        if (matches.length > 0) {\n            suggestedActions.push(action);\n            totalConfidence += matches.length * 0.2;\n        }\n    });\n    const hasActionIntent = suggestedActions.length > 0 && entities.some((e)=>e.type === \"order\");\n    return {\n        hasActionIntent,\n        suggestedActions,\n        confidence: Math.min(totalConfidence, 1.0)\n    };\n}\n/**\n * Generate a smart response suggestion for the Boxio System bot\n * Note: This generates a basic response. The actual order status will be checked\n * when the bot response is created to show contextual actions.\n */ function generateSystemResponse(parsedMessage) {\n    if (!parsedMessage.hasOrderNumber) {\n        return {\n            shouldRespond: false,\n            response: \"\",\n            actionCards: [],\n            orderNumber: undefined\n        };\n    }\n    const actionIntent = detectActionIntent(parsedMessage.originalContent, parsedMessage.entities);\n    const orderNumber = parsedMessage.orderNumbers[0]; // Use first detected order\n    // Generate basic action cards - these will be refined based on actual order status\n    const baseActionCards = [\n        {\n            action: \"view_order\",\n            label: \"View Order\",\n            icon: \"\\uD83D\\uDC41ï¸\"\n        },\n        {\n            action: \"edit_address\",\n            label: \"Edit Shipping Address\",\n            icon: \"\\uD83C\\uDFE0\"\n        },\n        {\n            action: \"edit_carrier\",\n            label: \"Edit Shipping Carrier\",\n            icon: \"\\uD83D\\uDE9A\"\n        },\n        {\n            action: \"track_order\",\n            label: \"Track Package\",\n            icon: \"\\uD83D\\uDCE6\"\n        },\n        {\n            action: \"edit_items\",\n            label: \"Edit Line Items\",\n            icon: \"\\uD83D\\uDCDD\"\n        }\n    ];\n    // If specific intent detected, prioritize those actions\n    if (actionIntent.hasActionIntent) {\n        const intentActionMap = {\n            \"update_address\": \"edit_address\",\n            \"modify_items\": \"edit_items\",\n            \"track_order\": \"track_order\",\n            \"expedite\": \"edit_carrier\"\n        };\n        // Mark matching actions as primary\n        baseActionCards.forEach((card)=>{\n            if (actionIntent.suggestedActions.some((intent)=>intentActionMap[intent] === card.action)) {\n                card.primary = true;\n            }\n        });\n    }\n    return {\n        shouldRespond: true,\n        response: \"I can help you with order #\".concat(orderNumber, \"! What would you like to do?\"),\n        actionCards: baseActionCards,\n        orderNumber\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbWVzc2FnZS1wYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBaUJEOzs7Ozs7Q0FNQyxHQUNELE1BQU1BLGlCQUFpQjtJQUNyQiw0RUFBNEU7SUFDNUU7SUFFQSxxRUFBcUU7SUFDckU7SUFFQSx1Q0FBdUM7SUFDdkM7SUFFQSx1REFBdUQ7SUFDdkQ7Q0FDRDtBQUVEOzs7O0NBSUMsR0FDRCxNQUFNQyxlQUFlO0lBQ25CO0lBQ0E7Q0FDRDtBQUVEOztDQUVDLEdBQ0QsTUFBTUMsb0JBQW9CO0lBQ3hCO0lBQ0E7Q0FDRDtBQUVEOztDQUVDLEdBQ00sU0FBU0MsYUFBYUMsT0FBZTtJQUMxQyxNQUFNQyxXQUE2QixFQUFFO0lBQ3JDLE1BQU1DLGVBQXlCLEVBQUU7SUFFakMsdUJBQXVCO0lBQ3ZCTixlQUFlTyxPQUFPLENBQUNDLENBQUFBO1FBQ3JCLE1BQU1DLFVBQVU7ZUFBSUwsUUFBUU0sUUFBUSxDQUFDRjtTQUFTO1FBQzlDQyxRQUFRRixPQUFPLENBQUNJLENBQUFBO1lBQ2QsMERBQTBEO1lBQzFELElBQUlDLGNBQWM7WUFDbEIsSUFBSUMsbUJBQW1CO1lBRXZCLElBQUlGLEtBQUssQ0FBQyxFQUFFLEVBQUU7Z0JBQ1osdUVBQXVFO2dCQUN2RUMsY0FBY0QsS0FBSyxDQUFDLEVBQUUsQ0FBQ0csV0FBVztnQkFDbENELG1CQUFtQkYsS0FBSyxDQUFDLEVBQUU7WUFDN0IsT0FBTyxJQUFJQSxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUNBLEtBQUssQ0FBQyxFQUFFLEVBQUU7Z0JBQ2hDLHVEQUF1RDtnQkFDdkRDLGNBQWNELEtBQUssQ0FBQyxFQUFFLENBQUNHLFdBQVc7Z0JBQ2xDRCxtQkFBbUJGLEtBQUssQ0FBQyxFQUFFO1lBQzdCO1lBRUEsSUFBSUMsZUFBZUMsa0JBQWtCO2dCQUNuQyxNQUFNRSxhQUFhSixNQUFNSyxLQUFLLEdBQUlMLEtBQUssQ0FBQyxFQUFFLENBQUNNLE9B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QVUsOEJBQTBDLE9BQVpoRCxhQUFZO1FBQ3BEaUQsYUFBYUc7UUFDYnBEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL21lc3NhZ2UtcGFyc2VyLnRzP2IyYmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNZXNzYWdlIFBhcnNlciBTZXJ2aWNlXG4gKiBEZXRlY3RzIGVudGl0aWVzIGxpa2Ugb3JkZXIgbnVtYmVycywgU0tVcywgdHJhY2tpbmcgbnVtYmVycyBpbiBjaGF0IG1lc3NhZ2VzXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBEZXRlY3RlZEVudGl0eSB7XG4gIHR5cGU6ICdvcmRlcicgfCAnc2t1JyB8ICd0cmFja2luZycgfCAnY3VzdG9tZXInO1xuICB2YWx1ZTogc3RyaW5nO1xuICBzdGFydEluZGV4OiBudW1iZXI7XG4gIGVuZEluZGV4OiBudW1iZXI7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRNZXNzYWdlIHtcbiAgb3JpZ2luYWxDb250ZW50OiBzdHJpbmc7XG4gIGVudGl0aWVzOiBEZXRlY3RlZEVudGl0eVtdO1xuICBoYXNPcmRlck51bWJlcjogYm9vbGVhbjtcbiAgb3JkZXJOdW1iZXJzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBPcmRlciBudW1iZXIgcGF0dGVybnMgdG8gZGV0ZWN0OlxuICogLSAjMTIzNDUsICMjMTIzNDUgKGxlZ2FjeSB3aXRoIGhhc2hlcyAtIG5vcm1hbGl6ZSB0byBjbGVhbiBudW1iZXIpXG4gKiAtIE9yZGVyIDEyMzQ1LCBPcmRlciAjMTIzNDVcbiAqIC0gb3JkZXIgbnVtYmVyIDEyMzQ1XG4gKiAtIFZhcmlvdXMgZm9ybWF0cyB3aXRoIGxldHRlcnMvbnVtYmVyc1xuICovXG5jb25zdCBPUkRFUl9QQVRURVJOUyA9IFtcbiAgLy8gSGFzaCBwcmVmaXg6ICMxMjM0NSwgIyMxMjM0NSwgI09SREVSLTEyMzQ1IChub3JtYWxpemUgYnkgcmVtb3ZpbmcgaGFzaGVzKVxuICAvKD86XnxcXHMpKCMrKShbQS1aXSpbMC05XXszLH1bQS1aMC05XSopL2dpLFxuICBcbiAgLy8gT3JkZXIga2V5d29yZDogXCJPcmRlciAxMjM0NVwiLCBcIm9yZGVyICMxMjM0NVwiLCBcIm9yZGVyIG51bWJlciAxMjM0NVwiXG4gIC8oPzpefFxccylvcmRlclxccyooPzpudW1iZXJcXHMqKT8oIyspPyhbQS1aMC05XXszLH0pL2dpLFxuICBcbiAgLy8gT3JkZXIgSUQgcGF0dGVybnM6IFwib3JkZXIgaWQ6IDEyMzQ1XCJcbiAgLyg/Ol58XFxzKW9yZGVyXFxzKmlkXFxzKjo/XFxzKigjKyk/KFtBLVowLTldezMsfSkvZ2ksXG4gIFxuICAvLyBTdGFuZGFsb25lIG51bWJlcnMgdGhhdCBsb29rIGxpa2Ugb3JkZXJzICg1KyBkaWdpdHMpXG4gIC8oPzpefFxccykoIyspPyhbMC05XXs1LH0pL2csXG5dO1xuXG4vKipcbiAqIFNLVSBwYXR0ZXJucyB0byBkZXRlY3Q6XG4gKiAtIFNLVTogQUJDMTIzLCBTS1UtQUJDMTIzXG4gKiAtIFByb2R1Y3QgY29kZXNcbiAqL1xuY29uc3QgU0tVX1BBVFRFUk5TID0gW1xuICAvKD86XnxcXHMpU0tVXFxzKjo/XFxzKihbQS1aMC05XFwtX117Myx9KS9naSxcbiAgLyg/Ol58XFxzKXByb2R1Y3RcXHMqKD86Y29kZXxpZClcXHMqOj9cXHMqKFtBLVowLTlcXC1fXXszLH0pL2dpLFxuXTtcblxuLyoqXG4gKiBUcmFja2luZyBudW1iZXIgcGF0dGVybnNcbiAqL1xuY29uc3QgVFJBQ0tJTkdfUEFUVEVSTlMgPSBbXG4gIC8oPzpefFxccyl0cmFja2luZ1xccyooPzpudW1iZXJ8Iyk/XFxzKjo/XFxzKihbQS1aMC05XXs4LH0pL2dpLFxuICAvKD86XnxcXHMpdHJhY2tcXHMqOj9cXHMqKFtBLVowLTldezgsfSkvZ2ksXG5dO1xuXG4vKipcbiAqIFBhcnNlIGEgbWVzc2FnZSBhbmQgZXh0cmFjdCBlbnRpdGllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNZXNzYWdlKGNvbnRlbnQ6IHN0cmluZyk6IFBhcnNlZE1lc3NhZ2Uge1xuICBjb25zdCBlbnRpdGllczogRGV0ZWN0ZWRFbnRpdHlbXSA9IFtdO1xuICBjb25zdCBvcmRlck51bWJlcnM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gRGV0ZWN0IG9yZGVyIG51bWJlcnNcbiAgT1JERVJfUEFUVEVSTlMuZm9yRWFjaChwYXR0ZXJuID0+IHtcbiAgICBjb25zdCBtYXRjaGVzID0gWy4uLmNvbnRlbnQubWF0Y2hBbGwocGF0dGVybildO1xuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBjbGVhbiBvcmRlciBudW1iZXIgKHJlbW92aW5nIGhhc2ggcHJlZml4ZXMpXG4gICAgICBsZXQgb3JkZXJOdW1iZXIgPSAnJztcbiAgICAgIGxldCBvcmRlck51bWJlck1hdGNoID0gJyc7XG4gICAgICBcbiAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAvLyBQYXR0ZXJuIHdpdGggaGFzaCBwcmVmaXg6IG1hdGNoWzFdID0gaGFzaGVzLCBtYXRjaFsyXSA9IG9yZGVyIG51bWJlclxuICAgICAgICBvcmRlck51bWJlciA9IG1hdGNoWzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIG9yZGVyTnVtYmVyTWF0Y2ggPSBtYXRjaFsyXTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0gJiYgIW1hdGNoWzJdKSB7XG4gICAgICAgIC8vIFBhdHRlcm4gd2l0aG91dCBoYXNoIHByZWZpeDogbWF0Y2hbMV0gPSBvcmRlciBudW1iZXJcbiAgICAgICAgb3JkZXJOdW1iZXIgPSBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBvcmRlck51bWJlck1hdGNoID0gbWF0Y2hbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChvcmRlck51bWJlciAmJiBvcmRlck51bWJlck1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBtYXRjaC5pbmRleCEgKyBtYXRjaFswXS5pbmRleE9mKG9yZGVyTnVtYmVyTWF0Y2gpO1xuICAgICAgICBcbiAgICAgICAgZW50aXRpZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ29yZGVyJyxcbiAgICAgICAgICB2YWx1ZTogb3JkZXJOdW1iZXIsIC8vIFN0b3JlIGNsZWFuIG9yZGVyIG51bWJlciB3aXRob3V0IGhhc2hlc1xuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZW5kSW5kZXg6IHN0YXJ0SW5kZXggKyBvcmRlck51bWJlck1hdGNoLmxlbmd0aCxcbiAgICAgICAgICBjb25maWRlbmNlOiBjYWxjdWxhdGVPcmRlckNvbmZpZGVuY2UobWF0Y2hbMF0sIGNvbnRlbnQpXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFvcmRlck51bWJlcnMuaW5jbHVkZXMob3JkZXJOdW1iZXIpKSB7XG4gICAgICAgICAgb3JkZXJOdW1iZXJzLnB1c2gob3JkZXJOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBTS1VzXG4gIFNLVV9QQVRURVJOUy5mb3JFYWNoKHBhdHRlcm4gPT4ge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbLi4uY29udGVudC5tYXRjaEFsbChwYXR0ZXJuKV07XG4gICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnc2t1JyxcbiAgICAgICAgICB2YWx1ZTogbWF0Y2hbMV0udG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBzdGFydEluZGV4OiBtYXRjaC5pbmRleCEgKyBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzFdKSxcbiAgICAgICAgICBlbmRJbmRleDogbWF0Y2guaW5kZXghICsgbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsxXSkgKyBtYXRjaFsxXS5sZW5ndGgsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC45XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBEZXRlY3QgdHJhY2tpbmcgbnVtYmVyc1xuICBUUkFDS0lOR19QQVRURVJOUy5mb3JFYWNoKHBhdHRlcm4gPT4ge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbLi4uY29udGVudC5tYXRjaEFsbChwYXR0ZXJuKV07XG4gICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAndHJhY2tpbmcnLFxuICAgICAgICAgIHZhbHVlOiBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIHN0YXJ0SW5kZXg6IG1hdGNoLmluZGV4ISArIG1hdGNoWzBdLmluZGV4T2YobWF0Y2hbMV0pLFxuICAgICAgICAgIGVuZEluZGV4OiBtYXRjaC5pbmRleCEgKyBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzFdKSArIG1hdGNoWzFdLmxlbmd0aCxcbiAgICAgICAgICBjb25maWRlbmNlOiAwLjk1XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBSZW1vdmUgZHVwbGljYXRlcyBhbmQgc29ydCBieSBjb25maWRlbmNlXG4gIGNvbnN0IHVuaXF1ZUVudGl0aWVzID0gZW50aXRpZXMuZmlsdGVyKChlbnRpdHksIGluZGV4LCBzZWxmKSA9PiBcbiAgICBpbmRleCA9PT0gc2VsZi5maW5kSW5kZXgoZSA9PiBlLnR5cGUgPT09IGVudGl0eS50eXBlICYmIGUudmFsdWUgPT09IGVudGl0eS52YWx1ZSlcbiAgKS5zb3J0KChhLCBiKSA9PiBiLmNvbmZpZGVuY2UgLSBhLmNvbmZpZGVuY2UpO1xuXG4gIHJldHVybiB7XG4gICAgb3JpZ2luYWxDb250ZW50OiBjb250ZW50LFxuICAgIGVudGl0aWVzOiB1bmlxdWVFbnRpdGllcyxcbiAgICBoYXNPcmRlck51bWJlcjogb3JkZXJOdW1iZXJzLmxlbmd0aCA+IDAsXG4gICAgb3JkZXJOdW1iZXJzOiBbLi4ubmV3IFNldChvcmRlck51bWJlcnMpXSAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBjb25maWRlbmNlIHNjb3JlIGZvciBvcmRlciBudW1iZXIgZGV0ZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9yZGVyQ29uZmlkZW5jZShtYXRjaDogc3RyaW5nLCBmdWxsQ29udGVudDogc3RyaW5nKTogbnVtYmVyIHtcbiAgbGV0IGNvbmZpZGVuY2UgPSAwLjc7IC8vIEJhc2UgY29uZmlkZW5jZVxuICBcbiAgLy8gSGlnaGVyIGNvbmZpZGVuY2UgaWYgZXhwbGljaXRseSBtZW50aW9uZWQgYXMgXCJvcmRlclwiXG4gIGlmICgvb3JkZXIvaS50ZXN0KG1hdGNoKSkge1xuICAgIGNvbmZpZGVuY2UgKz0gMC4yO1xuICB9XG4gIFxuICAvLyBIaWdoZXIgY29uZmlkZW5jZSBpZiBoYXNoIHByZWZpeFxuICBpZiAobWF0Y2guaW5jbHVkZXMoJyMnKSkge1xuICAgIGNvbmZpZGVuY2UgKz0gMC4xO1xuICB9XG4gIFxuICAvLyBDb250ZXh0IGNsdWVzIGluIHRoZSBmdWxsIG1lc3NhZ2VcbiAgY29uc3QgY29udGV4dENsdWVzID0gW1xuICAgICdjaGFuZ2UnLCAndXBkYXRlJywgJ2NhbmNlbCcsICdtb2RpZnknLCAnZWRpdCcsICdzaGlwJywgJ2FkZHJlc3MnLCBcbiAgICAnY3VzdG9tZXInLCAnZGVsaXZlcnknLCAndHJhY2tpbmcnLCAnc3RhdHVzJywgJ3Byb2JsZW0nLCAnaXNzdWUnXG4gIF07XG4gIFxuICBpZiAoY29udGV4dENsdWVzLnNvbWUoY2x1ZSA9PiBmdWxsQ29udGVudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGNsdWUpKSkge1xuICAgIGNvbmZpZGVuY2UgKz0gMC4xO1xuICB9XG4gIFxuICByZXR1cm4gTWF0aC5taW4oY29uZmlkZW5jZSwgMS4wKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIG1lc3NhZ2Ugc3VnZ2VzdHMgdGhlIHVzZXIgd2FudHMgdG8gdGFrZSBhY3Rpb24gb24gYW4gb3JkZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdEFjdGlvbkludGVudChjb250ZW50OiBzdHJpbmcsIGVudGl0aWVzOiBEZXRlY3RlZEVudGl0eVtdKToge1xuICBoYXNBY3Rpb25JbnRlbnQ6IGJvb2xlYW47XG4gIHN1Z2dlc3RlZEFjdGlvbnM6IHN0cmluZ1tdO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG59IHtcbiAgY29uc3QgbG93ZXJDb250ZW50ID0gY29udGVudC50b0xvd2VyQ2FzZSgpO1xuICBcbiAgY29uc3QgYWN0aW9uS2V5d29yZHMgPSB7XG4gICAgJ3VwZGF0ZV9hZGRyZXNzJzogWydhZGRyZXNzJywgJ3NoaXAgdG8nLCAnc2hpcHBpbmcnLCAnZGVsaXZlcnknLCAnbW92ZScsICdyZWxvY2F0ZSddLFxuICAgICdjYW5jZWxfb3JkZXInOiBbJ2NhbmNlbCcsICdzdG9wJywgJ2hhbHQnLCAnYWJvcnQnLCAncmVtb3ZlJ10sXG4gICAgJ21vZGlmeV9pdGVtcyc6IFsnYWRkJywgJ3JlbW92ZScsICdjaGFuZ2UgaXRlbXMnLCAnbW9kaWZ5JywgJ2RpZmZlcmVudCcsICdzd2FwJ10sXG4gICAgJ2V4cGVkaXRlJzogWydydXNoJywgJ3VyZ2VudCcsICdhc2FwJywgJ2V4cGVkaXRlJywgJ2Zhc3RlcicsICdwcmlvcml0eSddLFxuICAgICd0cmFja19vcmRlcic6IFsndHJhY2snLCAnc3RhdHVzJywgJ3doZXJlIGlzJywgJ3NoaXBwZWQnLCAnZGVsaXZlcnknXSxcbiAgICAnY29udGFjdF9jdXN0b21lcic6IFsnY3VzdG9tZXInLCAnY2xpZW50JywgJ2NvbnRhY3QnLCAnY2FsbCcsICdlbWFpbCddXG4gIH07XG4gIFxuICBjb25zdCBzdWdnZXN0ZWRBY3Rpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG90YWxDb25maWRlbmNlID0gMDtcbiAgXG4gIE9iamVjdC5lbnRyaWVzKGFjdGlvbktleXdvcmRzKS5mb3JFYWNoKChbYWN0aW9uLCBrZXl3b3Jkc10pID0+IHtcbiAgICBjb25zdCBtYXRjaGVzID0ga2V5d29yZHMuZmlsdGVyKGtleXdvcmQgPT4gbG93ZXJDb250ZW50LmluY2x1ZGVzKGtleXdvcmQpKTtcbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdWdnZXN0ZWRBY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgIHRvdGFsQ29uZmlkZW5jZSArPSBtYXRjaGVzLmxlbmd0aCAqIDAuMjtcbiAgICB9XG4gIH0pO1xuICBcbiAgY29uc3QgaGFzQWN0aW9uSW50ZW50ID0gc3VnZ2VzdGVkQWN0aW9ucy5sZW5ndGggPiAwICYmIGVudGl0aWVzLnNvbWUoZSA9PiBlLnR5cGUgPT09ICdvcmRlcicpO1xuICBcbiAgcmV0dXJuIHtcbiAgICBoYXNBY3Rpb25JbnRlbnQsXG4gICAgc3VnZ2VzdGVkQWN0aW9ucyxcbiAgICBjb25maWRlbmNlOiBNYXRoLm1pbih0b3RhbENvbmZpZGVuY2UsIDEuMClcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNtYXJ0IHJlc3BvbnNlIHN1Z2dlc3Rpb24gZm9yIHRoZSBCb3hpbyBTeXN0ZW0gYm90XG4gKiBOb3RlOiBUaGlzIGdlbmVyYXRlcyBhIGJhc2ljIHJlc3BvbnNlLiBUaGUgYWN0dWFsIG9yZGVyIHN0YXR1cyB3aWxsIGJlIGNoZWNrZWRcbiAqIHdoZW4gdGhlIGJvdCByZXNwb25zZSBpcyBjcmVhdGVkIHRvIHNob3cgY29udGV4dHVhbCBhY3Rpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTeXN0ZW1SZXNwb25zZShwYXJzZWRNZXNzYWdlOiBQYXJzZWRNZXNzYWdlKToge1xuICBzaG91bGRSZXNwb25kOiBib29sZWFuO1xuICByZXNwb25zZTogc3RyaW5nO1xuICBhY3Rpb25DYXJkczogQXJyYXk8e1xuICAgIGFjdGlvbjogc3RyaW5nO1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgaWNvbjogc3RyaW5nO1xuICAgIHByaW1hcnk/OiBib29sZWFuO1xuICB9PjtcbiAgb3JkZXJOdW1iZXI/OiBzdHJpbmc7XG59IHtcbiAgaWYgKCFwYXJzZWRNZXNzYWdlLmhhc09yZGVyTnVtYmVyKSB7XG4gICAgcmV0dXJuIHsgc2hvdWxkUmVzcG9uZDogZmFsc2UsIHJlc3BvbnNlOiAnJywgYWN0aW9uQ2FyZHM6IFtdLCBvcmRlck51bWJlcjogdW5kZWZpbmVkIH07XG4gIH1cbiAgXG4gIGNvbnN0IGFjdGlvbkludGVudCA9IGRldGVjdEFjdGlvbkludGVudChwYXJzZWRNZXNzYWdlLm9yaWdpbmFsQ29udGVudCwgcGFyc2VkTWVzc2FnZS5lbnRpdGllcyk7XG4gIGNvbnN0IG9yZGVyTnVtYmVyID0gcGFyc2VkTWVzc2FnZS5vcmRlck51bWJlcnNbMF07IC8vIFVzZSBmaXJzdCBkZXRlY3RlZCBvcmRlclxuICBcbiAgLy8gR2VuZXJhdGUgYmFzaWMgYWN0aW9uIGNhcmRzIC0gdGhlc2Ugd2lsbCBiZSByZWZpbmVkIGJhc2VkIG9uIGFjdHVhbCBvcmRlciBzdGF0dXNcbiAgY29uc3QgYmFzZUFjdGlvbkNhcmRzID0gW1xuICAgIHsgYWN0aW9uOiAndmlld19vcmRlcicsIGxhYmVsOiAnVmlldyBPcmRlcicsIGljb246ICfwn5GB77iPJyB9LFxuICAgIHsgYWN0aW9uOiAnZWRpdF9hZGRyZXNzJywgbGFiZWw6ICdFZGl0IFNoaXBwaW5nIEFkZHJlc3MnLCBpY29uOiAn8J+PoCcgfSxcbiAgICB7IGFjdGlvbjogJ2VkaXRfY2FycmllcicsIGxhYmVsOiAnRWRpdCBTaGlwcGluZyBDYXJyaWVyJywgaWNvbjogJ/CfmponIH0sXG4gICAgeyBhY3Rpb246ICd0cmFja19vcmRlcicsIGxhYmVsOiAnVHJhY2sgUGFja2FnZScsIGljb246ICfwn5OmJyB9LFxuICAgIHsgYWN0aW9uOiAnZWRpdF9pdGVtcycsIGxhYmVsOiAnRWRpdCBMaW5lIEl0ZW1zJywgaWNvbjogJ/Cfk50nIH1cbiAgXTtcbiAgXG4gIC8vIElmIHNwZWNpZmljIGludGVudCBkZXRlY3RlZCwgcHJpb3JpdGl6ZSB0aG9zZSBhY3Rpb25zXG4gIGlmIChhY3Rpb25JbnRlbnQuaGFzQWN0aW9uSW50ZW50KSB7XG4gICAgY29uc3QgaW50ZW50QWN0aW9uTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgJ3VwZGF0ZV9hZGRyZXNzJzogJ2VkaXRfYWRkcmVzcycsXG4gICAgICAnbW9kaWZ5X2l0ZW1zJzogJ2VkaXRfaXRlbXMnLFxuICAgICAgJ3RyYWNrX29yZGVyJzogJ3RyYWNrX29yZGVyJyxcbiAgICAgICdleHBlZGl0ZSc6ICdlZGl0X2NhcnJpZXInXG4gICAgfTtcbiAgICBcbiAgICAvLyBNYXJrIG1hdGNoaW5nIGFjdGlvbnMgYXMgcHJpbWFyeVxuICAgIGJhc2VBY3Rpb25DYXJkcy5mb3JFYWNoKGNhcmQgPT4ge1xuICAgICAgaWYgKGFjdGlvbkludGVudC5zdWdnZXN0ZWRBY3Rpb25zLnNvbWUoaW50ZW50ID0+IGludGVudEFjdGlvbk1hcFtpbnRlbnRdID09PSBjYXJkLmFjdGlvbikpIHtcbiAgICAgICAgY2FyZC5wcmltYXJ5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBzaG91bGRSZXNwb25kOiB0cnVlLFxuICAgIHJlc3BvbnNlOiBgSSBjYW4gaGVscCB5b3Ugd2l0aCBvcmRlciAjJHtvcmRlck51bWJlcn0hIFdoYXQgd291bGQgeW91IGxpa2UgdG8gZG8/YCxcbiAgICBhY3Rpb25DYXJkczogYmFzZUFjdGlvbkNhcmRzLFxuICAgIG9yZGVyTnVtYmVyXG4gIH07XG59XG4iXSwibmFtZXMiOlsiT1JERVJfUEFUVEVSTlMiLCJTS1VfUEFUVEVSTlMiLCJUUkFDS0lOR19QQVRURVJOUyIsInBhcnNlTWVzc2FnZSIsImNvbnRlbnQiLCJlbnRpdGllcyIsIm9yZGVyTnVtYmVycyIsImZvckVhY2giLCJwYXR0ZXJuIiwibWF0Y2hlcyIsIm1hdGNoQWxsIiwibWF0Y2giLCJvcmRlck51bWJlciIsIm9yZGVyTnVtYmVyTWF0Y2giLCJ0b1VwcGVyQ2FzZSIsInN0YXJ0SW5kZXgiLCJpbmRleCIsImluZGV4T2YiLCJwdXNoIiwidHlwZSIsInZhbHVlIiwiZW5kSW5kZXgiLCJsZW5ndGgiLCJjb25maWRlbmNlIiwiY2FsY3VsYXRlT3JkZXJDb25maWRlbmNlIiwiaW5jbHVkZXMiLCJ1bmlxdWVFbnRpdGllcyIsImZpbHRlciIsImVudGl0eSIsInNlbGYiLCJmaW5kSW5kZXgiLCJlIiwic29ydCIsImEiLCJiIiwib3JpZ2luYWxDb250ZW50IiwiaGFzT3JkZXJOdW1iZXIiLCJTZXQiLCJmdWxsQ29udGVudCIsInRlc3QiLCJjb250ZXh0Q2x1ZXMiLCJzb21lIiwiY2x1ZSIsInRvTG93ZXJDYXNlIiwiTWF0aCIsIm1pbiIsImRldGVjdEFjdGlvbkludGVudCIsImxvd2VyQ29udGVudCIsImFjdGlvbktleXdvcmRzIiwic3VnZ2VzdGVkQWN0aW9ucyIsInRvdGFsQ29uZmlkZW5jZSIsIk9iamVjdCIsImVudHJpZXMiLCJhY3Rpb24iLCJrZXl3b3JkcyIsImtleXdvcmQiLCJoYXNBY3Rpb25JbnRlbnQiLCJnZW5lcmF0ZVN5c3RlbVJlc3BvbnNlIiwicGFyc2VkTWVzc2FnZSIsInNob3VsZFJlc3BvbmQiLCJyZXNwb25zZSIsImFjdGlvbkNhcmRzIiwidW5kZWZpbmVkIiwiYWN0aW9uSW50ZW50IiwiYmFzZUFjdGlvbkNhcmRzIiwibGFiZWwiLCJpY29uIiwiaW50ZW50QWN0aW9uTWFwIiwiY2FyZCIsImludGVudCIsInByaW1hcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/message-parser.ts\n"));

/***/ })

});