"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./src/lib/message-parser.ts":
/*!***********************************!*\
  !*** ./src/lib/message-parser.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectActionIntent: function() { return /* binding */ detectActionIntent; },\n/* harmony export */   generateSystemResponse: function() { return /* binding */ generateSystemResponse; },\n/* harmony export */   parseMessage: function() { return /* binding */ parseMessage; }\n/* harmony export */ });\n/**\n * Message Parser Service\n * Detects entities like order numbers, SKUs, tracking numbers in chat messages\n */ /**\n * Order number patterns to detect:\n * - #12345, ##12345 (legacy with hashes - normalize to clean number)\n * - Order 12345, Order #12345\n * - order number 12345\n * - Various formats with letters/numbers\n */ const ORDER_PATTERNS = [\n    // Hash prefix: #12345, ##12345, #ORDER-12345 (normalize by removing hashes)\n    /(?:^|\\s)(#+)([A-Z]*[0-9]{3,}[A-Z0-9]*)/gi,\n    // Order keyword: \"Order 12345\", \"order #12345\", \"order number 12345\"\n    /(?:^|\\s)order\\s*(?:number\\s*)?(#+)?([A-Z0-9]{3,})/gi,\n    // Order ID patterns: \"order id: 12345\"\n    /(?:^|\\s)order\\s*id\\s*:?\\s*(#+)?([A-Z0-9]{3,})/gi,\n    // Standalone numbers that look like orders (5+ digits)\n    /(?:^|\\s)(#+)?([0-9]{5,})/g\n];\n/**\n * SKU patterns to detect:\n * - SKU: ABC123, SKU-ABC123\n * - Product codes\n */ const SKU_PATTERNS = [\n    /(?:^|\\s)SKU\\s*:?\\s*([A-Z0-9\\-_]{3,})/gi,\n    /(?:^|\\s)product\\s*(?:code|id)\\s*:?\\s*([A-Z0-9\\-_]{3,})/gi\n];\n/**\n * Tracking number patterns\n */ const TRACKING_PATTERNS = [\n    /(?:^|\\s)tracking\\s*(?:number|#)?\\s*:?\\s*([A-Z0-9]{8,})/gi,\n    /(?:^|\\s)track\\s*:?\\s*([A-Z0-9]{8,})/gi\n];\n/**\n * Parse a message and extract entities\n */ function parseMessage(content) {\n    const entities = [];\n    const orderNumbers = [];\n    // Detect order numbers\n    ORDER_PATTERNS.forEach((pattern)=>{\n        const matches = [\n            ...content.matchAll(pattern)\n        ];\n        matches.forEach((match)=>{\n            if (match[1]) {\n                const orderNumber = match[1].toUpperCase();\n                const startIndex = match.index + match[0].indexOf(match[1]);\n                entities.push({\n                    type: \"order\",\n                    value: orderNumber,\n                    startIndex,\n                    endIndex: startIndex + match[1].length,\n                    confidence: calculateOrderConfidence(match[0], content)\n                });\n                if (!orderNumbers.includes(orderNumber)) {\n                    orderNumbers.push(orderNumber);\n                }\n            }\n        });\n    });\n    // Detect SKUs\n    SKU_PATTERNS.forEach((pattern)=>{\n        const matches = [\n            ...content.matchAll(pattern)\n        ];\n        matches.forEach((match)=>{\n            if (match[1]) {\n                entities.push({\n                    type: \"sku\",\n                    value: match[1].toUpperCase(),\n                    startIndex: match.index + match[0].indexOf(match[1]),\n                    endIndex: match.index + match[0].indexOf(match[1]) + match[1].length,\n                    confidence: 0.9\n                });\n            }\n        });\n    });\n    // Detect tracking numbers\n    TRACKING_PATTERNS.forEach((pattern)=>{\n        const matches = [\n            ...content.matchAll(pattern)\n        ];\n        matches.forEach((match)=>{\n            if (match[1]) {\n                entities.push({\n                    type: \"tracking\",\n                    value: match[1].toUpperCase(),\n                    startIndex: match.index + match[0].indexOf(match[1]),\n                    endIndex: match.index + match[0].indexOf(match[1]) + match[1].length,\n                    confidence: 0.95\n                });\n            }\n        });\n    });\n    // Remove duplicates and sort by confidence\n    const uniqueEntities = entities.filter((entity, index, self)=>index === self.findIndex((e)=>e.type === entity.type && e.value === entity.value)).sort((a, b)=>b.confidence - a.confidence);\n    return {\n        originalContent: content,\n        entities: uniqueEntities,\n        hasOrderNumber: orderNumbers.length > 0,\n        orderNumbers: [\n            ...new Set(orderNumbers)\n        ] // Remove duplicates\n    };\n}\n/**\n * Calculate confidence score for order number detection\n */ function calculateOrderConfidence(match, fullContent) {\n    let confidence = 0.7; // Base confidence\n    // Higher confidence if explicitly mentioned as \"order\"\n    if (/order/i.test(match)) {\n        confidence += 0.2;\n    }\n    // Higher confidence if hash prefix\n    if (match.includes(\"#\")) {\n        confidence += 0.1;\n    }\n    // Context clues in the full message\n    const contextClues = [\n        \"change\",\n        \"update\",\n        \"cancel\",\n        \"modify\",\n        \"edit\",\n        \"ship\",\n        \"address\",\n        \"customer\",\n        \"delivery\",\n        \"tracking\",\n        \"status\",\n        \"problem\",\n        \"issue\"\n    ];\n    if (contextClues.some((clue)=>fullContent.toLowerCase().includes(clue))) {\n        confidence += 0.1;\n    }\n    return Math.min(confidence, 1.0);\n}\n/**\n * Check if a message suggests the user wants to take action on an order\n */ function detectActionIntent(content, entities) {\n    const lowerContent = content.toLowerCase();\n    const actionKeywords = {\n        \"update_address\": [\n            \"address\",\n            \"ship to\",\n            \"shipping\",\n            \"delivery\",\n            \"move\",\n            \"relocate\"\n        ],\n        \"cancel_order\": [\n            \"cancel\",\n            \"stop\",\n            \"halt\",\n            \"abort\",\n            \"remove\"\n        ],\n        \"modify_items\": [\n            \"add\",\n            \"remove\",\n            \"change items\",\n            \"modify\",\n            \"different\",\n            \"swap\"\n        ],\n        \"expedite\": [\n            \"rush\",\n            \"urgent\",\n            \"asap\",\n            \"expedite\",\n            \"faster\",\n            \"priority\"\n        ],\n        \"track_order\": [\n            \"track\",\n            \"status\",\n            \"where is\",\n            \"shipped\",\n            \"delivery\"\n        ],\n        \"contact_customer\": [\n            \"customer\",\n            \"client\",\n            \"contact\",\n            \"call\",\n            \"email\"\n        ]\n    };\n    const suggestedActions = [];\n    let totalConfidence = 0;\n    Object.entries(actionKeywords).forEach((param)=>{\n        let [action, keywords] = param;\n        const matches = keywords.filter((keyword)=>lowerContent.includes(keyword));\n        if (matches.length > 0) {\n            suggestedActions.push(action);\n            totalConfidence += matches.length * 0.2;\n        }\n    });\n    const hasActionIntent = suggestedActions.length > 0 && entities.some((e)=>e.type === \"order\");\n    return {\n        hasActionIntent,\n        suggestedActions,\n        confidence: Math.min(totalConfidence, 1.0)\n    };\n}\n/**\n * Generate a smart response suggestion for the Boxio System bot\n * Note: This generates a basic response. The actual order status will be checked\n * when the bot response is created to show contextual actions.\n */ function generateSystemResponse(parsedMessage) {\n    if (!parsedMessage.hasOrderNumber) {\n        return {\n            shouldRespond: false,\n            response: \"\",\n            actionCards: [],\n            orderNumber: undefined\n        };\n    }\n    const actionIntent = detectActionIntent(parsedMessage.originalContent, parsedMessage.entities);\n    const orderNumber = parsedMessage.orderNumbers[0]; // Use first detected order\n    // Generate basic action cards - these will be refined based on actual order status\n    const baseActionCards = [\n        {\n            action: \"view_order\",\n            label: \"View Order\",\n            icon: \"\\uD83D\\uDC41Ô∏è\"\n        },\n        {\n            action: \"edit_address\",\n            label: \"Edit Shipping Address\",\n            icon: \"\\uD83C\\uDFE0\"\n        },\n        {\n            action: \"edit_carrier\",\n            label: \"Edit Shipping Carrier\",\n            icon: \"\\uD83D\\uDE9A\"\n        },\n        {\n            action: \"track_order\",\n            label: \"Track Package\",\n            icon: \"\\uD83D\\uDCE6\"\n        },\n        {\n            action: \"edit_items\",\n            label: \"Edit Line Items\",\n            icon: \"\\uD83D\\uDCDD\"\n        }\n    ];\n    // If specific intent detected, prioritize those actions\n    if (actionIntent.hasActionIntent) {\n        const intentActionMap = {\n            \"update_address\": \"edit_address\",\n            \"modify_items\": \"edit_items\",\n            \"track_order\": \"track_order\",\n            \"expedite\": \"edit_carrier\"\n        };\n        // Mark matching actions as primary\n        baseActionCards.forEach((card)=>{\n            if (actionIntent.suggestedActions.some((intent)=>intentActionMap[intent] === card.action)) {\n                card.primary = true;\n            }\n        });\n    }\n    return {\n        shouldRespond: true,\n        response: \"I can help you with order #\".concat(orderNumber, \"! What would you like to do?\"),\n        actionCards: baseActionCards,\n        orderNumber\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbWVzc2FnZS1wYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBaUJEOzs7Ozs7Q0FNQyxHQUNELE1BQU1BLGlCQUFpQjtJQUNyQiw0RUFBNEU7SUFDNUU7SUFFQSxxRUFBcUU7SUFDckU7SUFFQSx1Q0FBdUM7SUFDdkM7SUFFQSx1REFBdUQ7SUFDdkQ7Q0FDRDtBQUVEOzs7O0NBSUMsR0FDRCxNQUFNQyxlQUFlO0lBQ25CO0lBQ0E7Q0FDRDtBQUVEOztDQUVDLEdBQ0QsTUFBTUMsb0JBQW9CO0lBQ3hCO0lBQ0E7Q0FDRDtBQUVEOztDQUVDLEdBQ00sU0FBU0MsYUFBYUMsT0FBZTtJQUMxQyxNQUFNQyxXQUE2QixFQUFFO0lBQ3JDLE1BQU1DLGVBQXlCLEVBQUU7SUFFakMsdUJBQXVCO0lBQ3ZCTixlQUFlTyxPQUFPLENBQUNDLENBQUFBO1FBQ3JCLE1BQU1DLFVBQVU7ZUFBSUwsUUFBUU0sUUFBUSxDQUFDRjtTQUFTO1FBQzlDQyxRQUFRRixPQUFPLENBQUNJLENBQUFBO1lBQ2QsSUFBSUEsS0FBSyxDQUFDLEVBQUUsRUFBRTtnQkFDWixNQUFNQyxjQUFjRCxLQUFLLENBQUMsRUFBRSxDQUFDRSxXQUFXO2dCQUN4QyxNQUFNQyxhQUFhSCxNQUFNSSxLQUFLLEdBQUlKLEtBQUssQ0FBQyxFQUFFLENBQUNLLE9BQU8sQ0FBQ0wsS0FBSyxDQUFDLEVBQUU7Z0JBRTNETixTQUFTWSxJQUFJLENBQUM7b0JBQ1pDLE1BQU07b0JBQ05DLE9BQU9QO29CQUNQRTtvQkFDQU0sVUFBVU4sYUFBYUgsS0FBSyxDQUFDLEVBQUUsQ0FBQ1UsTUFBTTtvQkFDdENDLFlBQVlDLHlCQUF5QlosS0FBSyxDQUFDLEVBQUUsRUFBRVA7Z0JBQ2pEO2dCQUVBLElBQUksQ0FBQ0UsYUFBYWtCLFFBQVEsQ0FBQ1osY0FBYztvQkFDdkNOLGFBQWFXLElBQUksQ0FBQ0w7Z0JBQ3BCO1lBQ0Y7UUFDRjtJQUNGO0lBRUEs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QWUsRUFBRXVCLGNBQWNwRCxRQUFRO0lBQzdGLE1BQU1PLGNBQWM2QyxjQUFjbkQsWUFBWSxDQUFDLEVBQUUsRUFBRSwyQkFBMkI7SUFFOUUsbUZBQW1GO0lBQ25GLE1BQU15RCxrQkFBa0I7UUFDdEI7WUFBRVgsUUFBUTtZQUFjWSxPQUFPO1lBQWNDLE1BQU07UUFBTTtRQUN6RDtZQUFFYixRQUFRO1lBQWdCWSxPQUFPO1lBQXlCQyxNQUFNO1FBQUs7UUFDckU7WUFBRWIsUUFBUTtZQUFnQlksT0FBTztZQUF5QkMsTUFBTTtRQUFLO1FBQ3JFO1lBQUViLFFBQVE7WUFBZVksT0FBTztZQUFpQkMsTUFBTTtRQUFLO1FBQzVEO1lBQUViLFFBQVE7WUFBY1ksT0FBTztZQUFtQkMsTUFBTTtRQUFLO0tBQzlEO0lBRUQsd0RBQXdEO0lBQ3hELElBQUlILGFBQWFQLGVBQWUsRUFBRTtRQUNoQyxNQUFNVyxrQkFBMEM7WUFDOUMsa0JBQWtCO1lBQ2xCLGdCQUFnQjtZQUNoQixlQUFlO1lBQ2YsWUFBWTtRQUNkO1FBRUEsbUNBQW1DO1FBQ25DSCxnQkFBZ0J4RCxPQUFPLENBQUM0RCxDQUFBQTtZQUN0QixJQUFJTCxhQUFhZCxnQkFBZ0IsQ0FBQ1IsSUFBSSxDQUFDNEIsQ0FBQUEsU0FBVUYsZUFBZSxDQUFDRSxPQUFPLEtBQUtELEtBQUtmLE1BQU0sR0FBRztnQkFDekZlLEtBQUtFLE9BQU8sR0FBRztZQUNqQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xYLGVBQWU7UUFDZkMsVUFBVSw4QkFBMEMsT0FBWi9DLGFBQVk7UUFDcERnRCxhQUFhRztRQUNibkQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvbWVzc2FnZS1wYXJzZXIudHM/YjJiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1lc3NhZ2UgUGFyc2VyIFNlcnZpY2VcbiAqIERldGVjdHMgZW50aXRpZXMgbGlrZSBvcmRlciBudW1iZXJzLCBTS1VzLCB0cmFja2luZyBudW1iZXJzIGluIGNoYXQgbWVzc2FnZXNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIERldGVjdGVkRW50aXR5IHtcbiAgdHlwZTogJ29yZGVyJyB8ICdza3UnIHwgJ3RyYWNraW5nJyB8ICdjdXN0b21lcic7XG4gIHZhbHVlOiBzdHJpbmc7XG4gIHN0YXJ0SW5kZXg6IG51bWJlcjtcbiAgZW5kSW5kZXg6IG51bWJlcjtcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZE1lc3NhZ2Uge1xuICBvcmlnaW5hbENvbnRlbnQ6IHN0cmluZztcbiAgZW50aXRpZXM6IERldGVjdGVkRW50aXR5W107XG4gIGhhc09yZGVyTnVtYmVyOiBib29sZWFuO1xuICBvcmRlck51bWJlcnM6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIE9yZGVyIG51bWJlciBwYXR0ZXJucyB0byBkZXRlY3Q6XG4gKiAtICMxMjM0NSwgIyMxMjM0NSAobGVnYWN5IHdpdGggaGFzaGVzIC0gbm9ybWFsaXplIHRvIGNsZWFuIG51bWJlcilcbiAqIC0gT3JkZXIgMTIzNDUsIE9yZGVyICMxMjM0NVxuICogLSBvcmRlciBudW1iZXIgMTIzNDVcbiAqIC0gVmFyaW91cyBmb3JtYXRzIHdpdGggbGV0dGVycy9udW1iZXJzXG4gKi9cbmNvbnN0IE9SREVSX1BBVFRFUk5TID0gW1xuICAvLyBIYXNoIHByZWZpeDogIzEyMzQ1LCAjIzEyMzQ1LCAjT1JERVItMTIzNDUgKG5vcm1hbGl6ZSBieSByZW1vdmluZyBoYXNoZXMpXG4gIC8oPzpefFxccykoIyspKFtBLVpdKlswLTldezMsfVtBLVowLTldKikvZ2ksXG4gIFxuICAvLyBPcmRlciBrZXl3b3JkOiBcIk9yZGVyIDEyMzQ1XCIsIFwib3JkZXIgIzEyMzQ1XCIsIFwib3JkZXIgbnVtYmVyIDEyMzQ1XCJcbiAgLyg/Ol58XFxzKW9yZGVyXFxzKig/Om51bWJlclxccyopPygjKyk/KFtBLVowLTldezMsfSkvZ2ksXG4gIFxuICAvLyBPcmRlciBJRCBwYXR0ZXJuczogXCJvcmRlciBpZDogMTIzNDVcIlxuICAvKD86XnxcXHMpb3JkZXJcXHMqaWRcXHMqOj9cXHMqKCMrKT8oW0EtWjAtOV17Myx9KS9naSxcbiAgXG4gIC8vIFN0YW5kYWxvbmUgbnVtYmVycyB0aGF0IGxvb2sgbGlrZSBvcmRlcnMgKDUrIGRpZ2l0cylcbiAgLyg/Ol58XFxzKSgjKyk/KFswLTldezUsfSkvZyxcbl07XG5cbi8qKlxuICogU0tVIHBhdHRlcm5zIHRvIGRldGVjdDpcbiAqIC0gU0tVOiBBQkMxMjMsIFNLVS1BQkMxMjNcbiAqIC0gUHJvZHVjdCBjb2Rlc1xuICovXG5jb25zdCBTS1VfUEFUVEVSTlMgPSBbXG4gIC8oPzpefFxccylTS1VcXHMqOj9cXHMqKFtBLVowLTlcXC1fXXszLH0pL2dpLFxuICAvKD86XnxcXHMpcHJvZHVjdFxccyooPzpjb2RlfGlkKVxccyo6P1xccyooW0EtWjAtOVxcLV9dezMsfSkvZ2ksXG5dO1xuXG4vKipcbiAqIFRyYWNraW5nIG51bWJlciBwYXR0ZXJuc1xuICovXG5jb25zdCBUUkFDS0lOR19QQVRURVJOUyA9IFtcbiAgLyg/Ol58XFxzKXRyYWNraW5nXFxzKig/Om51bWJlcnwjKT9cXHMqOj9cXHMqKFtBLVowLTldezgsfSkvZ2ksXG4gIC8oPzpefFxccyl0cmFja1xccyo6P1xccyooW0EtWjAtOV17OCx9KS9naSxcbl07XG5cbi8qKlxuICogUGFyc2UgYSBtZXNzYWdlIGFuZCBleHRyYWN0IGVudGl0aWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1lc3NhZ2UoY29udGVudDogc3RyaW5nKTogUGFyc2VkTWVzc2FnZSB7XG4gIGNvbnN0IGVudGl0aWVzOiBEZXRlY3RlZEVudGl0eVtdID0gW107XG4gIGNvbnN0IG9yZGVyTnVtYmVyczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBEZXRlY3Qgb3JkZXIgbnVtYmVyc1xuICBPUkRFUl9QQVRURVJOUy5mb3JFYWNoKHBhdHRlcm4gPT4ge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbLi4uY29udGVudC5tYXRjaEFsbChwYXR0ZXJuKV07XG4gICAgbWF0Y2hlcy5mb3JFYWNoKG1hdGNoID0+IHtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBvcmRlck51bWJlciA9IG1hdGNoWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBtYXRjaC5pbmRleCEgKyBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgXG4gICAgICAgIGVudGl0aWVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdvcmRlcicsXG4gICAgICAgICAgdmFsdWU6IG9yZGVyTnVtYmVyLFxuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZW5kSW5kZXg6IHN0YXJ0SW5kZXggKyBtYXRjaFsxXS5sZW5ndGgsXG4gICAgICAgICAgY29uZmlkZW5jZTogY2FsY3VsYXRlT3JkZXJDb25maWRlbmNlKG1hdGNoWzBdLCBjb250ZW50KVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghb3JkZXJOdW1iZXJzLmluY2x1ZGVzKG9yZGVyTnVtYmVyKSkge1xuICAgICAgICAgIG9yZGVyTnVtYmVycy5wdXNoKG9yZGVyTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICAvLyBEZXRlY3QgU0tVc1xuICBTS1VfUEFUVEVSTlMuZm9yRWFjaChwYXR0ZXJuID0+IHtcbiAgICBjb25zdCBtYXRjaGVzID0gWy4uLmNvbnRlbnQubWF0Y2hBbGwocGF0dGVybildO1xuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgZW50aXRpZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3NrdScsXG4gICAgICAgICAgdmFsdWU6IG1hdGNoWzFdLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgc3RhcnRJbmRleDogbWF0Y2guaW5kZXghICsgbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsxXSksXG4gICAgICAgICAgZW5kSW5kZXg6IG1hdGNoLmluZGV4ISArIG1hdGNoWzBdLmluZGV4T2YobWF0Y2hbMV0pICsgbWF0Y2hbMV0ubGVuZ3RoLFxuICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IHRyYWNraW5nIG51bWJlcnNcbiAgVFJBQ0tJTkdfUEFUVEVSTlMuZm9yRWFjaChwYXR0ZXJuID0+IHtcbiAgICBjb25zdCBtYXRjaGVzID0gWy4uLmNvbnRlbnQubWF0Y2hBbGwocGF0dGVybildO1xuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgZW50aXRpZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3RyYWNraW5nJyxcbiAgICAgICAgICB2YWx1ZTogbWF0Y2hbMV0udG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBzdGFydEluZGV4OiBtYXRjaC5pbmRleCEgKyBtYXRjaFswXS5pbmRleE9mKG1hdGNoWzFdKSxcbiAgICAgICAgICBlbmRJbmRleDogbWF0Y2guaW5kZXghICsgbWF0Y2hbMF0uaW5kZXhPZihtYXRjaFsxXSkgKyBtYXRjaFsxXS5sZW5ndGgsXG4gICAgICAgICAgY29uZmlkZW5jZTogMC45NVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXMgYW5kIHNvcnQgYnkgY29uZmlkZW5jZVxuICBjb25zdCB1bmlxdWVFbnRpdGllcyA9IGVudGl0aWVzLmZpbHRlcigoZW50aXR5LCBpbmRleCwgc2VsZikgPT4gXG4gICAgaW5kZXggPT09IHNlbGYuZmluZEluZGV4KGUgPT4gZS50eXBlID09PSBlbnRpdHkudHlwZSAmJiBlLnZhbHVlID09PSBlbnRpdHkudmFsdWUpXG4gICkuc29ydCgoYSwgYikgPT4gYi5jb25maWRlbmNlIC0gYS5jb25maWRlbmNlKTtcblxuICByZXR1cm4ge1xuICAgIG9yaWdpbmFsQ29udGVudDogY29udGVudCxcbiAgICBlbnRpdGllczogdW5pcXVlRW50aXRpZXMsXG4gICAgaGFzT3JkZXJOdW1iZXI6IG9yZGVyTnVtYmVycy5sZW5ndGggPiAwLFxuICAgIG9yZGVyTnVtYmVyczogWy4uLm5ldyBTZXQob3JkZXJOdW1iZXJzKV0gLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY29uZmlkZW5jZSBzY29yZSBmb3Igb3JkZXIgbnVtYmVyIGRldGVjdGlvblxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVPcmRlckNvbmZpZGVuY2UobWF0Y2g6IHN0cmluZywgZnVsbENvbnRlbnQ6IHN0cmluZyk6IG51bWJlciB7XG4gIGxldCBjb25maWRlbmNlID0gMC43OyAvLyBCYXNlIGNvbmZpZGVuY2VcbiAgXG4gIC8vIEhpZ2hlciBjb25maWRlbmNlIGlmIGV4cGxpY2l0bHkgbWVudGlvbmVkIGFzIFwib3JkZXJcIlxuICBpZiAoL29yZGVyL2kudGVzdChtYXRjaCkpIHtcbiAgICBjb25maWRlbmNlICs9IDAuMjtcbiAgfVxuICBcbiAgLy8gSGlnaGVyIGNvbmZpZGVuY2UgaWYgaGFzaCBwcmVmaXhcbiAgaWYgKG1hdGNoLmluY2x1ZGVzKCcjJykpIHtcbiAgICBjb25maWRlbmNlICs9IDAuMTtcbiAgfVxuICBcbiAgLy8gQ29udGV4dCBjbHVlcyBpbiB0aGUgZnVsbCBtZXNzYWdlXG4gIGNvbnN0IGNvbnRleHRDbHVlcyA9IFtcbiAgICAnY2hhbmdlJywgJ3VwZGF0ZScsICdjYW5jZWwnLCAnbW9kaWZ5JywgJ2VkaXQnLCAnc2hpcCcsICdhZGRyZXNzJywgXG4gICAgJ2N1c3RvbWVyJywgJ2RlbGl2ZXJ5JywgJ3RyYWNraW5nJywgJ3N0YXR1cycsICdwcm9ibGVtJywgJ2lzc3VlJ1xuICBdO1xuICBcbiAgaWYgKGNvbnRleHRDbHVlcy5zb21lKGNsdWUgPT4gZnVsbENvbnRlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhjbHVlKSkpIHtcbiAgICBjb25maWRlbmNlICs9IDAuMTtcbiAgfVxuICBcbiAgcmV0dXJuIE1hdGgubWluKGNvbmZpZGVuY2UsIDEuMCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBtZXNzYWdlIHN1Z2dlc3RzIHRoZSB1c2VyIHdhbnRzIHRvIHRha2UgYWN0aW9uIG9uIGFuIG9yZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RBY3Rpb25JbnRlbnQoY29udGVudDogc3RyaW5nLCBlbnRpdGllczogRGV0ZWN0ZWRFbnRpdHlbXSk6IHtcbiAgaGFzQWN0aW9uSW50ZW50OiBib29sZWFuO1xuICBzdWdnZXN0ZWRBY3Rpb25zOiBzdHJpbmdbXTtcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xufSB7XG4gIGNvbnN0IGxvd2VyQ29udGVudCA9IGNvbnRlbnQudG9Mb3dlckNhc2UoKTtcbiAgXG4gIGNvbnN0IGFjdGlvbktleXdvcmRzID0ge1xuICAgICd1cGRhdGVfYWRkcmVzcyc6IFsnYWRkcmVzcycsICdzaGlwIHRvJywgJ3NoaXBwaW5nJywgJ2RlbGl2ZXJ5JywgJ21vdmUnLCAncmVsb2NhdGUnXSxcbiAgICAnY2FuY2VsX29yZGVyJzogWydjYW5jZWwnLCAnc3RvcCcsICdoYWx0JywgJ2Fib3J0JywgJ3JlbW92ZSddLFxuICAgICdtb2RpZnlfaXRlbXMnOiBbJ2FkZCcsICdyZW1vdmUnLCAnY2hhbmdlIGl0ZW1zJywgJ21vZGlmeScsICdkaWZmZXJlbnQnLCAnc3dhcCddLFxuICAgICdleHBlZGl0ZSc6IFsncnVzaCcsICd1cmdlbnQnLCAnYXNhcCcsICdleHBlZGl0ZScsICdmYXN0ZXInLCAncHJpb3JpdHknXSxcbiAgICAndHJhY2tfb3JkZXInOiBbJ3RyYWNrJywgJ3N0YXR1cycsICd3aGVyZSBpcycsICdzaGlwcGVkJywgJ2RlbGl2ZXJ5J10sXG4gICAgJ2NvbnRhY3RfY3VzdG9tZXInOiBbJ2N1c3RvbWVyJywgJ2NsaWVudCcsICdjb250YWN0JywgJ2NhbGwnLCAnZW1haWwnXVxuICB9O1xuICBcbiAgY29uc3Qgc3VnZ2VzdGVkQWN0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHRvdGFsQ29uZmlkZW5jZSA9IDA7XG4gIFxuICBPYmplY3QuZW50cmllcyhhY3Rpb25LZXl3b3JkcykuZm9yRWFjaCgoW2FjdGlvbiwga2V5d29yZHNdKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGtleXdvcmRzLmZpbHRlcihrZXl3b3JkID0+IGxvd2VyQ29udGVudC5pbmNsdWRlcyhrZXl3b3JkKSk7XG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3VnZ2VzdGVkQWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICB0b3RhbENvbmZpZGVuY2UgKz0gbWF0Y2hlcy5sZW5ndGggKiAwLjI7XG4gICAgfVxuICB9KTtcbiAgXG4gIGNvbnN0IGhhc0FjdGlvbkludGVudCA9IHN1Z2dlc3RlZEFjdGlvbnMubGVuZ3RoID4gMCAmJiBlbnRpdGllcy5zb21lKGUgPT4gZS50eXBlID09PSAnb3JkZXInKTtcbiAgXG4gIHJldHVybiB7XG4gICAgaGFzQWN0aW9uSW50ZW50LFxuICAgIHN1Z2dlc3RlZEFjdGlvbnMsXG4gICAgY29uZmlkZW5jZTogTWF0aC5taW4odG90YWxDb25maWRlbmNlLCAxLjApXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzbWFydCByZXNwb25zZSBzdWdnZXN0aW9uIGZvciB0aGUgQm94aW8gU3lzdGVtIGJvdFxuICogTm90ZTogVGhpcyBnZW5lcmF0ZXMgYSBiYXNpYyByZXNwb25zZS4gVGhlIGFjdHVhbCBvcmRlciBzdGF0dXMgd2lsbCBiZSBjaGVja2VkXG4gKiB3aGVuIHRoZSBib3QgcmVzcG9uc2UgaXMgY3JlYXRlZCB0byBzaG93IGNvbnRleHR1YWwgYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU3lzdGVtUmVzcG9uc2UocGFyc2VkTWVzc2FnZTogUGFyc2VkTWVzc2FnZSk6IHtcbiAgc2hvdWxkUmVzcG9uZDogYm9vbGVhbjtcbiAgcmVzcG9uc2U6IHN0cmluZztcbiAgYWN0aW9uQ2FyZHM6IEFycmF5PHtcbiAgICBhY3Rpb246IHN0cmluZztcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIGljb246IHN0cmluZztcbiAgICBwcmltYXJ5PzogYm9vbGVhbjtcbiAgfT47XG4gIG9yZGVyTnVtYmVyPzogc3RyaW5nO1xufSB7XG4gIGlmICghcGFyc2VkTWVzc2FnZS5oYXNPcmRlck51bWJlcikge1xuICAgIHJldHVybiB7IHNob3VsZFJlc3BvbmQ6IGZhbHNlLCByZXNwb25zZTogJycsIGFjdGlvbkNhcmRzOiBbXSwgb3JkZXJOdW1iZXI6IHVuZGVmaW5lZCB9O1xuICB9XG4gIFxuICBjb25zdCBhY3Rpb25JbnRlbnQgPSBkZXRlY3RBY3Rpb25JbnRlbnQocGFyc2VkTWVzc2FnZS5vcmlnaW5hbENvbnRlbnQsIHBhcnNlZE1lc3NhZ2UuZW50aXRpZXMpO1xuICBjb25zdCBvcmRlck51bWJlciA9IHBhcnNlZE1lc3NhZ2Uub3JkZXJOdW1iZXJzWzBdOyAvLyBVc2UgZmlyc3QgZGV0ZWN0ZWQgb3JkZXJcbiAgXG4gIC8vIEdlbmVyYXRlIGJhc2ljIGFjdGlvbiBjYXJkcyAtIHRoZXNlIHdpbGwgYmUgcmVmaW5lZCBiYXNlZCBvbiBhY3R1YWwgb3JkZXIgc3RhdHVzXG4gIGNvbnN0IGJhc2VBY3Rpb25DYXJkcyA9IFtcbiAgICB7IGFjdGlvbjogJ3ZpZXdfb3JkZXInLCBsYWJlbDogJ1ZpZXcgT3JkZXInLCBpY29uOiAn8J+Rge+4jycgfSxcbiAgICB7IGFjdGlvbjogJ2VkaXRfYWRkcmVzcycsIGxhYmVsOiAnRWRpdCBTaGlwcGluZyBBZGRyZXNzJywgaWNvbjogJ/Cfj6AnIH0sXG4gICAgeyBhY3Rpb246ICdlZGl0X2NhcnJpZXInLCBsYWJlbDogJ0VkaXQgU2hpcHBpbmcgQ2FycmllcicsIGljb246ICfwn5qaJyB9LFxuICAgIHsgYWN0aW9uOiAndHJhY2tfb3JkZXInLCBsYWJlbDogJ1RyYWNrIFBhY2thZ2UnLCBpY29uOiAn8J+TpicgfSxcbiAgICB7IGFjdGlvbjogJ2VkaXRfaXRlbXMnLCBsYWJlbDogJ0VkaXQgTGluZSBJdGVtcycsIGljb246ICfwn5OdJyB9XG4gIF07XG4gIFxuICAvLyBJZiBzcGVjaWZpYyBpbnRlbnQgZGV0ZWN0ZWQsIHByaW9yaXRpemUgdGhvc2UgYWN0aW9uc1xuICBpZiAoYWN0aW9uSW50ZW50Lmhhc0FjdGlvbkludGVudCkge1xuICAgIGNvbnN0IGludGVudEFjdGlvbk1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICd1cGRhdGVfYWRkcmVzcyc6ICdlZGl0X2FkZHJlc3MnLFxuICAgICAgJ21vZGlmeV9pdGVtcyc6ICdlZGl0X2l0ZW1zJyxcbiAgICAgICd0cmFja19vcmRlcic6ICd0cmFja19vcmRlcicsXG4gICAgICAnZXhwZWRpdGUnOiAnZWRpdF9jYXJyaWVyJ1xuICAgIH07XG4gICAgXG4gICAgLy8gTWFyayBtYXRjaGluZyBhY3Rpb25zIGFzIHByaW1hcnlcbiAgICBiYXNlQWN0aW9uQ2FyZHMuZm9yRWFjaChjYXJkID0+IHtcbiAgICAgIGlmIChhY3Rpb25JbnRlbnQuc3VnZ2VzdGVkQWN0aW9ucy5zb21lKGludGVudCA9PiBpbnRlbnRBY3Rpb25NYXBbaW50ZW50XSA9PT0gY2FyZC5hY3Rpb24pKSB7XG4gICAgICAgIGNhcmQucHJpbWFyeSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgc2hvdWxkUmVzcG9uZDogdHJ1ZSxcbiAgICByZXNwb25zZTogYEkgY2FuIGhlbHAgeW91IHdpdGggb3JkZXIgIyR7b3JkZXJOdW1iZXJ9ISBXaGF0IHdvdWxkIHlvdSBsaWtlIHRvIGRvP2AsXG4gICAgYWN0aW9uQ2FyZHM6IGJhc2VBY3Rpb25DYXJkcyxcbiAgICBvcmRlck51bWJlclxuICB9O1xufVxuIl0sIm5hbWVzIjpbIk9SREVSX1BBVFRFUk5TIiwiU0tVX1BBVFRFUk5TIiwiVFJBQ0tJTkdfUEFUVEVSTlMiLCJwYXJzZU1lc3NhZ2UiLCJjb250ZW50IiwiZW50aXRpZXMiLCJvcmRlck51bWJlcnMiLCJmb3JFYWNoIiwicGF0dGVybiIsIm1hdGNoZXMiLCJtYXRjaEFsbCIsIm1hdGNoIiwib3JkZXJOdW1iZXIiLCJ0b1VwcGVyQ2FzZSIsInN0YXJ0SW5kZXgiLCJpbmRleCIsImluZGV4T2YiLCJwdXNoIiwidHlwZSIsInZhbHVlIiwiZW5kSW5kZXgiLCJsZW5ndGgiLCJjb25maWRlbmNlIiwiY2FsY3VsYXRlT3JkZXJDb25maWRlbmNlIiwiaW5jbHVkZXMiLCJ1bmlxdWVFbnRpdGllcyIsImZpbHRlciIsImVudGl0eSIsInNlbGYiLCJmaW5kSW5kZXgiLCJlIiwic29ydCIsImEiLCJiIiwib3JpZ2luYWxDb250ZW50IiwiaGFzT3JkZXJOdW1iZXIiLCJTZXQiLCJmdWxsQ29udGVudCIsInRlc3QiLCJjb250ZXh0Q2x1ZXMiLCJzb21lIiwiY2x1ZSIsInRvTG93ZXJDYXNlIiwiTWF0aCIsIm1pbiIsImRldGVjdEFjdGlvbkludGVudCIsImxvd2VyQ29udGVudCIsImFjdGlvbktleXdvcmRzIiwic3VnZ2VzdGVkQWN0aW9ucyIsInRvdGFsQ29uZmlkZW5jZSIsIk9iamVjdCIsImVudHJpZXMiLCJhY3Rpb24iLCJrZXl3b3JkcyIsImtleXdvcmQiLCJoYXNBY3Rpb25JbnRlbnQiLCJnZW5lcmF0ZVN5c3RlbVJlc3BvbnNlIiwicGFyc2VkTWVzc2FnZSIsInNob3VsZFJlc3BvbmQiLCJyZXNwb25zZSIsImFjdGlvbkNhcmRzIiwidW5kZWZpbmVkIiwiYWN0aW9uSW50ZW50IiwiYmFzZUFjdGlvbkNhcmRzIiwibGFiZWwiLCJpY29uIiwiaW50ZW50QWN0aW9uTWFwIiwiY2FyZCIsImludGVudCIsInByaW1hcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/message-parser.ts\n"));

/***/ })

});